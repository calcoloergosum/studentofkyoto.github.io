<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-05T23:39:33+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">한재승의 잡다한 생각저장소</title><subtitle>좋은 하루 되세요</subtitle><entry><title type="html">메타프로그래밍: 카테고리 이론; 들어가며</title><link href="http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0.html" rel="alternate" type="text/html" title="메타프로그래밍: 카테고리 이론; 들어가며" /><published>2022-11-05T22:40:00+09:00</published><updated>2022-11-05T22:40:00+09:00</updated><id>http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D:%20%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0</id><content type="html" xml:base="http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0.html">&lt;h1 id=&quot;메타프로그래밍-카테고리-이론서론&quot;&gt;메타프로그래밍: 카테고리 이론/서론&lt;/h1&gt;

&lt;h2 id=&quot;잡담&quot;&gt;잡담&lt;/h2&gt;

&lt;h3 id=&quot;메타프로그래밍이-필요한-이유&quot;&gt;메타프로그래밍이 필요한 이유&lt;/h3&gt;
&lt;p&gt;모든 소프트웨어 개발은 (소프트웨어의 정의 상) 지적 노동이고, 계속적으로 자신의 직관이 맞는지 틀린지를 확인하게 된다. 그러다 보면 개발에 사용하는 논리적 언어의 구조의 한계에 마주할 수 밖에 없다. 사양과 설계, 구현을 관통하는 어떤 개념이 존재한다는 것은 거의 모든 프로그래머가 직관적으로 알고 있다. 그러나 그 개념을 실제 프로젝트에 도입하는 것은 불가능한 경우가 대부분이다. 그 이유로는 프로젝트 여건 상 혹은 하드웨어와의 인터페이스의 문제 등이 있겠다. 따라서 이 개념은 구체화 되지 못하고 어중간한 “패러다임”으로 남게 된다. 구체화 되지 못한 개념은 Best Practice를 통해서만 재생산되고, 그 과정에서 왜곡되고 변형되어 종교 비슷한 것이 된다.&lt;/p&gt;

&lt;p&gt;모든 메타프로그래머들의 숙명은 현실적 타협점을 적절하게 설정해, 흐릿한 개념을 구체적이고 정확한 경계를 가지는 논리적 구조로 정제하는 것이다. 그리고 그 능력은 논리적 직관을 단련한 뒤에만 가능하다. 논리적 직관을 부호로 표기하며 습득, 재생산 하는 과정(즉, 수학)을 통해 논리적 직관의 표현을 단련하는 것은 반드시 필요하다. 이를 통해서 소프트웨어의 설계 능력을 비약적으로 향상시킬 수 있고, 다른 사람을 (논리적으로) 설득할 수 있게 되는 것이다.&lt;/p&gt;

&lt;h3 id=&quot;메타프로그래밍이-필요-없는-이유&quot;&gt;메타프로그래밍이 필요 없는 이유&lt;/h3&gt;

&lt;p&gt;모든 좋은 최적화는 주어진 문제의 정보를 최대한으로 활용한다. 따라서 최고의 프로그램을 작성하려고 한다면 추상화는 쓸모가 없다. 국소적으로, 단계적으로 최고의 프로그램을 향해 나아간다는 전제에서만 추상화가 쓸모가 있다. 적절한 추상화라는 것은 문제의 제약 조건을 활용함으로써 정보의 일부분을 의도적으로 누락한다는 것이고, 제약 조건이 어떻게 변하는지를 예상할 수 없는 상황이라면 적절한 추상화를 고려하는 것 자체가 어불성설이다.&lt;/p&gt;

&lt;p&gt;따라서 메타프로그래밍은 코드에 드러나지 않을 때 비로소 빛난다. 논리적인 추상화가 구현에 드러날 필요가 없다는 것이다. 그저 설계하는 사람이 알고 있으면 되며, 주석을 길게 써야할 만큼 추상적인 설계는 애시당초 해서는 안된다. 하지만 언젠가 누군가가 당신에게 왜 하필 이 방법을 택했는가를 물어본다면, 당신은 논리적으로 설명할 수 있을 것이다. 그리고 주어진 문제가 변경될 때, 기존의 추상화를 재고하지 않아도 효율적으로 기존의 구현을 변경할 수 있다.&lt;/p&gt;

&lt;p&gt;코드와 논리적 구조를 분리한다는 점에서, 카테고리 이론은 하나의 프로그래밍 언어라고 볼 수 있다. 이 프로그래밍 언어는 현재까지 인간이 갖고 있는 최고급(high-level) 프로그래밍 언어로, 우리 인간의 논리적 직관이 바로 이 언어로 쓰여졌다고 해도 과언이 아니다. 그리고 그 컴파일러는 바로 프로그래머 자신이다.&lt;/p&gt;

&lt;h3 id=&quot;주된-대상-독자&quot;&gt;주된 대상 독자&lt;/h3&gt;

&lt;p&gt;“좋은” 소프트웨어를 “효율적으로” 작성하는 데에 관심이 있는 열정가&lt;/p&gt;</content><author><name></name></author><summary type="html">메타프로그래밍: 카테고리 이론/서론</summary></entry><entry><title type="html">메타프로그래밍: 목차</title><link href="http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A9%EC%B0%A8.html" rel="alternate" type="text/html" title="메타프로그래밍: 목차" /><published>2022-11-05T22:40:00+09:00</published><updated>2022-11-05T22:40:00+09:00</updated><id>http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D:%20%EB%AA%A9%EC%B0%A8</id><content type="html" xml:base="http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%AA%A9%EC%B0%A8.html">&lt;h3 id=&quot;메타프로그래밍-카테고리-이론&quot;&gt;메타프로그래밍: 카테고리 이론&lt;/h3&gt;

&lt;p&gt;&lt;a href=&quot;/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0.html&quot;&gt;들어가며&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC%EC%9D%98-%EC%A0%95%EC%9D%98.html&quot;&gt;카테고리의 정의&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">메타프로그래밍: 카테고리 이론</summary></entry><entry><title type="html">메타프로그래밍: 카테고리의 정의</title><link href="http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC%EC%9D%98-%EC%A0%95%EC%9D%98.html" rel="alternate" type="text/html" title="메타프로그래밍: 카테고리의 정의" /><published>2022-11-05T20:40:05+09:00</published><updated>2022-11-05T20:40:05+09:00</updated><id>http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D:%20%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC%EC%9D%98%20%EC%A0%95%EC%9D%98</id><content type="html" xml:base="http://localhost:4000/2022/11/05/%EB%A9%94%ED%83%80%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%B9%B4%ED%85%8C%EA%B3%A0%EB%A6%AC%EC%9D%98-%EC%A0%95%EC%9D%98.html">&lt;h1 id=&quot;카테고리의-정의&quot;&gt;카테고리의 정의&lt;/h1&gt;
&lt;h2 id=&quot;직관&quot;&gt;직관&lt;/h2&gt;

&lt;p&gt;카테고리는 점들의 모임과 그 점 사이의 관계의 모임으로 구성되어 있다. 관계의 모임은 “동일하다”는 관계를 포함하고, 특정 관계들을 합쳐 다른 관계를 만들 수도 있다.&lt;/p&gt;

&lt;p&gt;카테고리는 方向그래프(directed graph)에 합성의 개념을 추가한 것이다. 합성이란, 화살표 여럿을 하나의 화살표로 합치는 것을 의미한다. 또한 각각의 頂点(vertex)은 “항등원” 이라고 부르는, 자기 자신으로의 화살표를 적어도 하나 가진다.&lt;/p&gt;

&lt;p&gt;카테고리는 점(object)의 모임과 화살표(arrow; morphism)의 모임으로 이루어져 있다. 각 화살표에는 시작점(source object)와 끝점(target object)이 있다. \(f\) 의 시작점이 \(x\)이고 끝점이 \(y\) 이면 “ \(f: x\rightarrow y\) “라고 쓰고, “\(x\) 에서 \(y\) 로의 화살표”라고 읽는다.&lt;/p&gt;

&lt;p&gt;카테고리에서는 화살표 \(g:x\rightarrow y\) 와 \(f:y\rightarrow z\)를 합성해 \(f\circ g:x\rightarrow z\) 라는 화살표를 얻는다. 이를 \(f\) after \(g\) 라고 읽는다. \(g;f\) 라고 쓰고 \(g\) then \(f\) 라고 읽기도 한다.&lt;/p&gt;

&lt;p&gt;합성 순서를 바꾸어도 화살표는 같다. 즉, 모든 세 개의 화살표 \(h:w\rightarrow x\), \(g:x\rightarrow y\) , \(f:y\rightarrow z\) 에 대해 \((h\circ g) \circ f = h \circ (g \circ f)\) 이다. 따라서 괄호를 제거하고 \(h\circ g \circ f\) 로 간단히 표기한다.&lt;/p&gt;

&lt;p&gt;집합의 카테고리 Set에서는, 모든 집합은 하나의 점이고, 모든 화살표는 두 집합 사이의 함수이다. 화살표의 합성은 함수의 합성으로 정의된다.&lt;/p&gt;

&lt;h2 id=&quot;정의&quot;&gt;정의&lt;/h2&gt;

&lt;p&gt;카테고리를 주로 정의하는 방법은 두 가지가 있는데, 둘 다 아는 것이 좋다. 왜냐하면 카테고리 이론의 분야에 따라 표기법이 다르다. 한 정의는 Internal category라는 개념으로 확장하기 쉽고, 다른 정의는 enriched category로 확장하기 쉽다. 둘 다 중요한 개념이다. 같은 대상에 대한 서로 다른 記術에 대해서 동치성을 증명할 때, 특정한 정의를 채용하는 것이 더 적절할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;정의-1&quot;&gt;정의 1&lt;/h3&gt;
&lt;h4 id=&quot;카테고리의-구성요소&quot;&gt;카테고리의 구성요소&lt;/h4&gt;
&lt;p&gt;카테고리 \(C\) 는 다음의 요소로 구성된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;점의 모임 \(C_0\)&lt;/li&gt;
  &lt;li&gt;화살표의 모임 \(C_1\)&lt;/li&gt;
  &lt;li&gt;모든 화살표에 정의된 시작점(source, domain) \(s(f)\) 과 끝점 (destination, codomain) \(t(f)\).&lt;/li&gt;
  &lt;li&gt;\(f\) 와 \(g\) 의 합성: \(t(f) = s(g)\) 를 만족하는 모든 화살표 쌍 \(f, g\) 에 정의된 화살표 \(g \circ f\)&lt;/li&gt;
  &lt;li&gt;각 점 \(x\)에 정의된 항등 화살표 (identity morphism) \(1_x\)
    &lt;h4 id=&quot;구성-요소가-만족해야-할-조건&quot;&gt;구성 요소가 만족해야 할 조건&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;합성은 시작점과 끝점을 보존한다. 즉, \(s(g\circ f) = s(f)\) 이고 \(t(g\circ f) = t(g)\) 이다.&lt;/li&gt;
  &lt;li&gt;점 \(x\)의 항등 화살표 \(1_x\) 는 시작점과 끝점이 \(x\) 이다. 즉, \(s(1_x) = t(1_x) = x\)&lt;/li&gt;
  &lt;li&gt;합성은 결합법칙이 성립한다. 세 화살표 \(f, g, h\) 가 있고 \(t(f) = s(g)\) 이고 \(t(g) = s(h)\) 일때 (즉, 합성이 정의될 때), \((h\circ g) \circ f = h \circ (g \circ f)\) 이다.&lt;/li&gt;
  &lt;li&gt;항등 화살표는 결합의 항등원이다. 즉, \(s(f)=x\) 이고 \(t(f)=y\) 일때, \(1_y\circ f=f\circ 1_x = f\) 이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;syntactic-sugar&quot;&gt;Syntactic Sugar&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;점과 화살표가 맥락상 명확히 구분될 때, \(x\in C_0\) 나 \(f\in C_1\) 대신 \(x\in C\) 혹은 \(f \in C\)와 같이 첨자를 생략하여 표시한다.&lt;/li&gt;
  &lt;li&gt;화살표 \(f\in C_1\)가 \(s(f)=x\), \(t(f)=y\)라고 할 때, \(f:x\rightarrow y\)로 쓴다.&lt;/li&gt;
  &lt;li&gt;\(s(f)=x, t(f)=y\)를 만족하는 \(f\)의 모임을 \(C(x,y)\)라고 쓴다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;정의-2&quot;&gt;정의 2&lt;/h3&gt;
&lt;h4 id=&quot;카테고리의-구성요소-1&quot;&gt;카테고리의 구성요소&lt;/h4&gt;
&lt;p&gt;카테고리 \(C\) 는 다음의 요소로 구성된다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;점의 모임 \(C_0\)&lt;/li&gt;
  &lt;li&gt;모든 두 점 \(x\), \(y\)에 대해, \(x\)에서 \(y\)로의 화살표의 모임 \(C_1(x,y)\)&lt;/li&gt;
  &lt;li&gt;모든 \(f\in C_1(x,y)\)와 \(g \in C_1(y,z)\)에 정의된 \(g\circ f \in C_1(x,z)\)&lt;/li&gt;
  &lt;li&gt;각 점 \(x\)에 정의된 항등 화살표 (identity morphism) \(1_x\)
    &lt;h4 id=&quot;구성-요소가-만족해야-할-조건-1&quot;&gt;구성 요소가 만족해야 할 조건&lt;/h4&gt;
  &lt;/li&gt;
  &lt;li&gt;합성은 결합법칙이 성립한다. 즉 네 점 \(w,x,y,z\)과 세 화살표 \(f\in C_1(w,x), g\in C_1(x,y), h\in C_1(y, z)\)가 주어졌을 때 (즉, 합성이 정의될 때), \((h\circ g) \circ f = h \circ (g \circ f)\) 이다.&lt;/li&gt;
  &lt;li&gt;항등 화살표는 결합의 항등원이다. 즉, 두 \(x,y\)과 화살표 \(f\in C_1(x,y)\)가 주어졌을 때, \(1_y\circ f=f\circ 1_x = f\) 이다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;syntactic-sugar-1&quot;&gt;Syntactic Sugar&lt;/h4&gt;
&lt;ol&gt;
  &lt;li&gt;점과 화살표가 맥락상 명확히 구분될 때, \(x\in C_0\) 나 \(f\in C_1(x,y)\) 대신 \(x\in C\) 혹은 \(f \in C(x,y)\)와 같이 첨자를 생략하여 표시한다.&lt;/li&gt;
  &lt;li&gt;\(f \in C_1(x, y)\)이면, \(s(f)=x\), \(t(f)=y\)라고 쓴다. 또한, \(f:x\rightarrow y\)로 쓴다.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;remark&quot;&gt;Remark&lt;/h3&gt;
&lt;p&gt;위의 두 정의는 동치이다.&lt;/p&gt;

&lt;h4 id=&quot;모임-이라는-단어의-쓰임새에-대해&quot;&gt;“모임” 이라는 단어의 쓰임새에 대해&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;카테고리의 정의에서는, “모임”이라는 단어에 대해 일부러 애매하게 쓴다.&lt;/li&gt;
  &lt;li&gt;집합의 카테고리 Set의 점의 모임은 집합이 아니라는 것을 쉽게 증명할 수 있다. 즉, 모든 집합의 집합은 집합이 아니다 (그보다 크다; Russell의 역설)&lt;/li&gt;
  &lt;li&gt;카테고리의 점의 모임이 집합인 경우, 카테고리가 작다(small)고 한다.&lt;/li&gt;
  &lt;li&gt;카테고리의 모든 점 \(x,y\in C_0\)에 대해, 각 \(C(x,y)\)가 집합인 경우, 카테고리가 국소적으로 작다(locally small)라고 한다.&lt;/li&gt;
  &lt;li&gt;카테고리가 국소적으로 작지 않은 경우, 카테고리가 크다(large)고 한다.&lt;/li&gt;
  &lt;li&gt;이 모임이라는 단어의 쓰임새는 수학적 기초론을 깊게 얘기하기 않고는 제대로 다룰 수 없다. 하지만 카테고리 이론을 도구로써 사용하는 데에는 문제가 되지 않는다. 왜냐하면 우리가 생각하고자 하는 대상은 카테고리 그 자체가 아니고, 카테고리의 구조에 더해 어떤 추가적인 성질을 가지고 있는 대상이기 때문이다.&lt;/li&gt;
  &lt;li&gt;프로그래머가 관심을 가질 만한 카테고리는 적어도 국소적으로 작다. 지금 당장 너무 깊게 생각하지 말고, 때를 기다리자.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;예시&quot;&gt;예시&lt;/h2&gt;

&lt;p&gt;많은 수학적 구조들을 카테고리로 볼 수 있다. 아래의 각 예시들에서, 화살표의 합성이 무엇인지 생각해보자.&lt;/p&gt;

&lt;p&gt;카테고리의 고전적인 예시는 “구체적인 카테고리(concrete category)”라는 것인데, 각 점이 집합이고, 그에 더해 추가적인 구조를 가진다. 이 카테고리에서 화살표는 그 추가적인 구조들을 보존한다. 카테고리라는 용어가 여기서 파생되었다. 말 그대로 동일한 종류(동일한 카테고리)의 구조들과 구조를 보존하는 사상들을, 카테고리라는 하나의 구조로 압축해 다루고자 한 것이다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;선형 공간의 카테고리를 Vect라고 한다.
    &lt;ul&gt;
      &lt;li&gt;Vect의 점은 선형 공간이다.&lt;/li&gt;
      &lt;li&gt;Vect의 화살표는 선형 공간 사이의 선형 변환이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;군의 카테고리를 Grp라고 한다.
    &lt;ul&gt;
      &lt;li&gt;Grp의 점은 군이다.&lt;/li&gt;
      &lt;li&gt;Grp의 화살표는 군 준동형사상이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;위상 공간의 카테고리를 Top이라고 한다.
    &lt;ul&gt;
      &lt;li&gt;Top의 점은 위상 공간이다.&lt;/li&gt;
      &lt;li&gt;Top의 화살표는 연속 함수이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;미분 다양체의 카테고리를 Diff라고 한다.
    &lt;ul&gt;
      &lt;li&gt;Diff의 점은 Smooth 다양체이다.&lt;/li&gt;
      &lt;li&gt;Diff의 화살표는 smooth map이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;환의 카테고리를 Ring이라고 한다.
    &lt;ul&gt;
      &lt;li&gt;Ring의 점은 환이다.&lt;/li&gt;
      &lt;li&gt;Ring의 화살표는 환 준동형사상이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;특정 집합을 카테고리로 볼 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;모든 부분순서집합 Poset은 카테고리이다
    &lt;ul&gt;
      &lt;li&gt;Poset의 점은 원소이다&lt;/li&gt;
      &lt;li&gt;Poset의 화살표는 대소관계이다&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;모든 모노이드 Monoid 는 카테고리이다.
    &lt;ul&gt;
      &lt;li&gt;점은 하나 뿐이다.&lt;/li&gt;
      &lt;li&gt;화살표는 각 원소이다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;앞으로의-전개&quot;&gt;앞으로의 전개&lt;/h2&gt;

&lt;p&gt;어떤 수학적 구조를 추상화하여 정의한 뒤에 가장 먼저 생각하고 싶은 것은 다음과 같다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이 구조를 보존하는 변환에는 어떤 것이 있는가?&lt;/li&gt;
  &lt;li&gt;구체적인 예에서 중요한 정의들이 추상화 한 뒤에도 잘 정의되는가?&lt;/li&gt;
  &lt;li&gt;구체적인 예에서 중요한 정리들이 추상화 한 뒤에도 성립하는가?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;하나씩 살펴보자.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;이 구조를 보존하는 변환에는 어떤 것이 있는가?
    &lt;ul&gt;
      &lt;li&gt;구조를 보존하는 변환을 생각하는 것은 유용하다. “쉬운” 카테고리에서 여러 성질을 발견한 뒤, “어려운” 카테고리로 관심을 옮겨, 그 성질들이 여전히 성립한다는 것을 보장할 수 있기 때문이다.&lt;/li&gt;
      &lt;li&gt;간단한 예로, 반대 카테고리(Opposite Category)를 생각해보자.
        &lt;ul&gt;
          &lt;li&gt;카테고리 \(C\)가 주어졌을 때, \(C_1\)의 모든 화살표의 방향을 반대로 돌려버린 모임 \(C_1^{op}\)로 \(C_1\)을 대체해보자. 화살표의 합성의 정의를 조금만 바꾸어주면, 여전히 카테고리가 되도록 할 수 있다. \(f:x\rightarrow y\), \(g:y\rightarrow z\)가 주어져서, 화살표의 방향을 뒤집은 새로운 화살표를 \(f^{op}:y\rightarrow x, g^{op}:z\rightarrow y\)라고 하자. \(C\) 에서의 합성 \(\circ^{op}\)를 \(f^{op} \circ^{op} g^{op} = (g \circ f)^op\)로 정의하면 뒤집은 화살표들이 카테고리임을 알 수 있다. 이 카테고리를 \(C\) 의 반대 카테고리(Opposite category) \(C^{op}\)라고 한다.&lt;/li&gt;
          &lt;li&gt;이 카테고리는 두 가지 이유에서 유용하다.
            &lt;ul&gt;
              &lt;li&gt;합성의 순서를 바꿀 수 있다.&lt;/li&gt;
              &lt;li&gt;카테고리 \(C\)에서 어떤 정리가 참이면, \(C^{op}\) 에서도 참이다.&lt;/li&gt;
            &lt;/ul&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;또 다른 예로, 곱 카테고리(Product Category)를 소개한다.
        &lt;ul&gt;
          &lt;li&gt;카테고리 여러 개를 하나의 카테고리로 합칠 수 있다. 두 카테고리 \(C, D\)가 주어졌을 때, 곱 카테고리 \(C\times D\) 를 다음과 같이 정의한다.&lt;/li&gt;
          &lt;li&gt;점은 \(C, D\)의 점\(c, d\)의 순서쌍 \((c, d)\) 이다.&lt;/li&gt;
          &lt;li&gt;화살표는 \(C, D\) 의 화살표 \(f, g\)의 순서쌍 \((f, g)\)이다.&lt;/li&gt;
          &lt;li&gt;합성은 각 카테고리의 성분별 합성으로 정의한다.&lt;/li&gt;
          &lt;li&gt;항등원은 \(1_{(c, d)}=(1_c, 1_d)\) 이다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;그 외에도 일반적으로 여러 카테고리 사이의 구조 보존을 생각할 수 있는데, 이를 일반적으로 함자라고 부른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구체적인 예에서 중요한 정의들이 추상화 한 뒤에도 잘 정의되는가?
    &lt;ul&gt;
      &lt;li&gt;첫 번째 과제는, 집합의 구조인 원소(membership)를 사용하지 않고도 집합의 주요한 정의들을 사용할 수 있는지 확인하는 것이다.
        &lt;ul&gt;
          &lt;li&gt;공집합, 전체집합, (분리)합집합, 교집합, 여집합, 차집합, 전사, 단사, 전단사, 부분집합, …&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;이를 확인하고 나면, 집합 위에 정의된 다양한 개념들이 잘 정의되는지 확인할 수 있을 것이다.
        &lt;ul&gt;
          &lt;li&gt;극한, 연속성, 적분, …&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;구체적인 예에서 중요한 정리들이 추상화 한 뒤에도 성립하는가?
    &lt;ul&gt;
      &lt;li&gt;이를 확인하는 작업까지 도달했다면, 호기심의 흐름에 몸을 맡겨 자신의 전문성에 맞는 구체적인 응용 분야를 탐구할 수 있지 않을까 조심스럽게 생각해 본다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;note&quot;&gt;Note&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;집합론에서 순서쌍의 수학적 구현을 알고 있다면, 위에서 소개한 곱 카테고리의 정의가 이상해 보일 수 있다. 곱 카테고리의 존재를 공리로써 받아들여 순서쌍의 구현에 대한 고민을 회피할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><summary type="html">카테고리의 정의 직관</summary></entry><entry><title type="html">바나흐 공간의 쌍대와 이중 쌍대</title><link href="http://localhost:4000/category/theory,/natural/transformation/2022/11/05/%EB%B0%94%EB%82%98%ED%9D%90-%EA%B3%B5%EA%B0%84%EC%9D%98-%EC%8C%8D%EB%8C%80%EC%99%80-%EC%9D%B4%EC%A4%91-%EC%8C%8D%EB%8C%80.html" rel="alternate" type="text/html" title="바나흐 공간의 쌍대와 이중 쌍대" /><published>2022-11-05T12:00:00+09:00</published><updated>2022-11-05T12:00:00+09:00</updated><id>http://localhost:4000/category/theory,/natural/transformation/2022/11/05/%EB%B0%94%EB%82%98%ED%9D%90%20%EA%B3%B5%EA%B0%84%EC%9D%98%20%EC%8C%8D%EB%8C%80%EC%99%80%20%EC%9D%B4%EC%A4%91%20%EC%8C%8D%EB%8C%80</id><content type="html" xml:base="http://localhost:4000/category/theory,/natural/transformation/2022/11/05/%EB%B0%94%EB%82%98%ED%9D%90-%EA%B3%B5%EA%B0%84%EC%9D%98-%EC%8C%8D%EB%8C%80%EC%99%80-%EC%9D%B4%EC%A4%91-%EC%8C%8D%EB%8C%80.html">&lt;p&gt;&lt;a href=&quot;https://www.johndcook.com/blog/2017/03/16/duals-and-double-duals-of-banach-spaces/&quot;&gt;원문 보기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;자연 변환과 비자연 변환(unnatural transformation)의 표준적인 예는 선형대수학에서 나오는데, 바로 벡터 공간과 쌍대 공간, 그리고 이중 쌍대공간의 관계이다. 유한 차원의 경우에 대해 잠깐 살펴보고, 무한 차원의 경우에 집중해보자.&lt;/p&gt;

&lt;p&gt;같은 체(field) 위의 두 유한 차원 벡터 공간은 동형이라는 것은 차원이 같다는 것과 동치이다.&lt;/p&gt;

&lt;p&gt;유한 차원 공간 \(V\)에 대해, 이 공간의 쌍대 공간 \(V^*\)는 선형 범함수들의 공간으로, 즉 \(V\) 에서 V가 정의된 체로 보내는 선형 함수들의 집합이다. 공간 \(V^*\) 는 \(V\)와 같은 차원을 가지므로 두 공간은 동형이다. 같은 식으로 한 번 더 반복할 수 있는데, 바로 쌍대 공간의 쌍대 공간을 생각해 \(V^{**}\)를 정의하는 것이다. &lt;em&gt;이 또한 같은 차원을 가지므로, \(V\), \(V^*\), \(V^{**}\)는 모두 동형이다&lt;/em&gt;. 하지만, \(V\) 는 \(V^{**}\)와 자연 동형이지만, \(V^*\)와는 자연 동형이 아니다. 즉, \(V\) 에서 \(V^*\)로의 변환은 자연스럽지 않다.&lt;/p&gt;

&lt;p&gt;선형 대수에서는 무한 차원(즉, 바나흐 공간)을 보는 것이 더 쉬울 때가 있다. 유한 공간에서는 사소해 보이는 차이가 무한 차원에서는 명백하게 문제가 된다.&lt;/p&gt;

&lt;p&gt;바나흐 공간의 카테고리는 선형 공간과 그 사이의 연속 선형 변환을 고려한다. 유한 차원 유클리드 공간에서는 모든 선형 변환이 연속이지만, 무한 차원에서는 선형 변환이 반드시 연속은 아니다.&lt;/p&gt;

&lt;p&gt;바나흐 공간 \(V\)의 쌍대 공간은 \(V\)의 연속 선형 함수의 공간이다. 즉 \(V\)가 \(V^*\)와 자연 동형이 아닐 뿐만 아니라, 아예 동형이 아닌 예이다.&lt;/p&gt;

&lt;p&gt;어떤 실수 \(p &amp;gt; 1\)에 대해, \(q\) 가 \(1/p  + 1/q = 1\)를 만족한다고 하자. 바나흐 공간 \(L_p\)는 \(\|f\|_p\) 의 적분이 유한인 의 르벡 적분 가능 함수 \(f\)들의 (동치류의) 집합이다. \(L_p\) 의 쌍대 공간은 \(L_q\)이다. \(p\)가 2가 아니면, 이 두 공간은 다르다. (\(p\)가 2이면 \(q\) 도 2이다; \(L_2\) 는 힐베르트 공간이고 쌍대 공간은 분명 같은 공간이다.)&lt;/p&gt;

&lt;p&gt;유한 차원의 경우, 벡터 공간 \(V\)는 \(V^**\)와 동형이다. 일반적으로는, \(V\)는 \(V^{**}\)에 embed할 수 있지만, \(V^{**}\)가 더 큰 공간일지도 모른다. \(V^{**}\) 에서의 \(V\)의 embedding은 직관적으로도, 자연변환의 형식적인 의미에서도 자연스럽다. \(V\)의 원소를 선형 함수의 범함수로 다음과 같이 변환할 수 있다:&lt;/p&gt;

&lt;p&gt;\(v\) 가 \(V\) 의 원소이고, \(f\) 가 \(V*\) 의 원소라고 하자. \(v(f)\) 는 단순히 \(f(v)\) 이다. 즉, \(v\)는 선형 함수를 자기 자신에 작용시킴으로써 작용한다!&lt;/p&gt;

&lt;p&gt;이는 \(v\)의 원소의 함수값에서 오는 \(V^{**}\)의 원소들이 있다는 것을 보여주지만, 여기서 끝나지 않는다. 위의 르벡 공간의 예로 돌아와서, \(L_1\)의 쌍대 공간은 \(L_\infty\)인데 이는 유계 함수의 공간이다. 하지만 \(L_\infty\)의 쌍대 공간은 \(L_1\) 보다 크다. 유계 함수의 연속 선형 범함수를 만드는 방법 중 하나는 절대 적분 가능 함수를 곱한 뒤 적분하는 것이다. 이 외에도 \(L_\infty\)에서 선형 범함수를 만드는 방법은 여럿 있다.&lt;/p&gt;

&lt;p&gt;바나흐 공간 \(V\) 는 \(V^**\)로의 자연 embedding이 동형사상일때 반사적이라고 한다. \(p &amp;gt; 1\)이면 \(\|L_p\|\) 는 반사적이다.&lt;/p&gt;

&lt;p&gt;하지만 R. C. James는 이중 쌍대 공간과 동형이지만 자연 동형이 아닌 경우가 있다는 놀라운 결과를 발표했다. 즉, \(V\)와 \(V^{**}\)가 동형이기는 하지만, 자연 embedding이 아닌 공간이 존재한다는 것이다; \(V\)의 \(V^{**}\)로의 자연 embedding이 동형사상이 아니다.&lt;/p&gt;</content><author><name></name></author><category term="category" /><category term="theory," /><category term="natural" /><category term="transformation" /><summary type="html">원문 보기</summary></entry><entry><title type="html">자연 변환</title><link href="http://localhost:4000/category/theory,/natural/transformation/2022/11/05/%EC%9E%90%EC%97%B0-%EB%B3%80%ED%99%98.html" rel="alternate" type="text/html" title="자연 변환" /><published>2022-11-05T11:00:05+09:00</published><updated>2022-11-05T11:00:05+09:00</updated><id>http://localhost:4000/category/theory,/natural/transformation/2022/11/05/%EC%9E%90%EC%97%B0%20%EB%B3%80%ED%99%98</id><content type="html" xml:base="http://localhost:4000/category/theory,/natural/transformation/2022/11/05/%EC%9E%90%EC%97%B0-%EB%B3%80%ED%99%98.html">&lt;p&gt;&lt;a href=&quot;https://www.johndcook.com/blog/2017/03/16/natural-transformations/&quot;&gt;원문 보기&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;카테고리 이론의 추상화의 사다리는 카테고리로 시작하여, 그 후 함자, 그리고 자연 변환에 이른다. 하지만 안타깝게도 자연 변환의 정의는 한 눈에 보기에 그다지 자연스럽지 않다. 카테고리 이론이 발전하게 된 첫 동기가 “자연스러움”을 정식화定式化하는 것이었다는 걸 생각해 보면, 참 역설적이다. 역사적으로, 함자는 자연 변환을 정의하기 위해 정의되었고, 카테고리는 함자를 정의하기 위해 정의되었다. 지금의 순서와는 정반대이다.&lt;/p&gt;

&lt;p&gt;카테고리는 점과 점 사이의 “화살표”들의 모임이다. 여기서 화살표란 대개 함수이지만, 일반적으로 함수일 필요는 없다.&lt;/p&gt;

&lt;p&gt;함자는 한 카테고리를 다른 카테고리로 보낸다. 카테고리는 점과 선으로 이루어져 있으니, 함자는 점을 점으로, 선을 선으로 보낸다.&lt;/p&gt;

&lt;p&gt;자연 변환은 함자를 함자로 보낸다. 그럴듯하게 들리는데, 이게 무슨 뜻일까?&lt;/p&gt;

&lt;p&gt;함자를 한 카테고리를 다른 카테고리 안에 그리는 한 방법이라고 생각할 수 있다. 어떤 카테고리가 있고, 그 카테고리에서 두 점 \(A\), \(B\)을 골라, 그 사이의 화살표 \(f\)가 있다고 하자. 이 때 함자 \(F\) 는 \(A\) 와 \(B\) 를 다른 카테고리의 점 \(FA\) 와 \(FB\) 로 보낸다. 같은 식으로 다른 함자 \(G\) 대해서도 반복한다. 그럼 첫 카테고리에서 점 \(A\) 와 \(B\), 그리고 화살표 \(f\)는 \(F\) 와 \(G\) 각각에 의해 다른 카테고리에서의 점과 선으로 대응되는데, 아래 그림과 같다.&lt;/p&gt;

\[\begin{CD}
    FA     @. @.  GA   \\
    @VV{Ff}V @.  @VV{Gf}V\\
    FB     @. @. GB
\end{CD}\]

&lt;p&gt;자연 변환 \(\alpha\) 는, 위의 도식에서 \(F\) 와 \(G\) 사이를 연결해 commute하게 한다.&lt;/p&gt;

\[\begin{CD}
    FA     @&amp;gt;\alpha_A&amp;gt;&amp;gt;  GA   \\
    @VV{Ff}V  @VV{Gf}V\\
    FB     @&amp;gt;\alpha_B&amp;gt;&amp;gt; GB
\end{CD}\]

&lt;p&gt;자연 변환은 원래 카테고리의 점 하나 당 새로운 카테고리에서 화살표 하나를 가지는 화살표들의 모임이다. 따라서 각 화살표들을 원래 카테고리의 점에 대해 첨자를 붙여, 점 A에 대응되는 화살표는 \(\alpha_A\), 점 B에 대응되는 화살표는 \(\alpha_B\) 이다. 이 화살표들은 각각 점 \(A\), \(B\) 에서의 \(\alpha\)의 성분(component)이라고 부른다.&lt;/p&gt;

&lt;p&gt;\(\alpha\) 의 성분들은 점 \(A\)와 \(B\)에 의존하지만, \(f\)에는 의존하지 않는다는 점에 주목해야 한다. \(f\)가 원래 카테고리에서 \(A\)에서 \(B\)로 보내는 화살표를 바꾸어도, 위 다이어그램의 \(\alpha_A\) 와 \(\alpha_B\) 는 바뀌지 않는다.&lt;/p&gt;

&lt;p&gt;자연 변환은 어떤 임의의 선택에도 의존하지 않는다는 의미에서, 변환이 “자연스럽다”라는 것을 개념을 표현한다. 한 변환이 어떤 임의의 선택에 의존한다면, \(f\)를 바꿈에 따라 \(\alpha_A\) 와 \(\alpha_B\) 또한 바꾸어야 할 것이다.&lt;/p&gt;

&lt;p&gt;다음 포스트에서는 자연 변환과 비-자연 변환의 표준적인 예를 다룬다.&lt;/p&gt;</content><author><name></name></author><category term="category" /><category term="theory," /><category term="natural" /><category term="transformation" /><summary type="html">원문 보기</summary></entry></feed>